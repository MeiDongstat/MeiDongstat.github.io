---
title: "Introducing {surveydown}: An markdown-based framework for generating surveys with Quarto and shiny (that now exists!!!)"
description: |
  A quick overview of the {surveydown} R package for making markdown-based surveys with open-source technologies: Quarto, shiny, and supabase.
date: '2024-08-08'
preview: "logo.png"
categories:
  - R
  - package
  - markdown
  - shiny
  - package
  - quarto
format: html
toc: true
lightbox: true
execute:
  eval: false
---

<link rel="stylesheet" href="surveydown.css">

```{r}
#| eval: true
#| include: false

library(fontawesome)
library(surveydown)
```

<center>
<img src="logo.png" width=200>
</center>
<br>

You may have read my [previous blog post](https://jhelvy.com/blog/2023-04-06-markdown-surveys/) about an R packaged I called "surveydown". That post described some ideas I was thinking about for a package that would allow people to design surveys using markdown and R. But the package didn't exist yet, it was just an idea. 

Well, I have good news: **the package now exists!** 

In this post, I'm going to show you a quick overview of the {surveydown} R package for making markdown-based surveys.

Later in the post I'll explain a little more about _why_ we built surveydown as well as some of the tools we used to build it.

# What is surveydown?

If you've never used surveydown before, the video on [this page]() offers a 5 minute overview that you might find helpful.

[surveydown](https://jhelvy.github.io/surveydown/) is a flexible platform for making surveys in `r fa("r-project")` using three open source technologies:
[Quarto](https://quarto.org/), [shiny](https://shiny.posit.co/), and
[supabase](https://supabase.com/).

<center>
<img src="technologies.png" width=600>
</center>
<br>

The basic concept is this:

1.  Design your survey as a [Quarto shiny
    document](https://quarto.org/docs/dashboards/interactivity/shiny-r.html)
    using markdown and R code.
2.  Render your doc into a [shiny](https://shiny.posit.co/) app that can
    be hosted online and sent to respondents.
3.  Store your survey responses in a [supabase](https://supabase.com/)
    database.

The package is still in development, but you can already use it to create surveys. 

# Getting started 

After getting everything [installed](https://jhelvy.github.io/surveydown/articles/installation.html), we recommend starting with a template survey project. You can create one with the following R command:

```{r}
surveydown::sd_create_survey("path/to/folder")
```

The `"path/to/folder"` is the path to where you want the template to be created. Once created, you'll see the following files / folders:

```
example.qmd
_extensions
example.Rproj
```

The only file you will need to edit is the `example.qmd` file. This is the main survey file that you will edit and customize for your survey. The `example.Rproj` is just a project file, which I recommend opening to edit your `example.qmd` file in RStudio (if you're using it). Finally, the `_extensions` folder contains the [surveydown Quarto extension](https://github.com/jhelvy/surveydown-ext) needed to make everything work. You can safely ignore this folder - just know that it's needed to make everything work.

If you have the example open, you can click the "Run document" button (in RStudio) or in your terminal run `quarto serve example.qmd`. Either approach should render the example survey into a shiny app that you can preview in a browser. Don't worry just yet about setting up your database or making the survey live - for now, we're going to focus on designing the survey and running it locally to preview it. The example survey should look like this:

<center>
<img src="example.png" width=700>
</center>

# A new way to design surveys

In surveydown, your entire survey is designed using markdown and R code in a single Quarto document. There is no GUI or drag-and-drop interface - simply write plain text (markdown and R code) and boom - you have a survey! 

The [{surveydown} package](https://jhelvy.github.io/surveydown/) provides a set of functions that allow you to define the survey content and control logic. Each function starts with `sd_` to make it easy to identify.

To edit your survey, you can add text using markdown formatting, or in RStudio you can edit with the visual editor, which inserts the markdown code for you. Survey questions are defined in R code chunks with a `sd_question()` function from the {surveydown} package. Pages are created using fences, with navigation handled with the `sd_next()` function. 

Once all of the survey content is defined (pages, text, images, questions, etc.), you can modify the control logic in the server code chunk (the last code chunk at the bottom of the .qmd file) with the `sd_config()` function. Finally, in the same server code chunk you can define the database configuration with the `sd_database()` function to store the survey response data. 

We'll get to all of this step-by-step.

## Adding pages

In surveydown, pages are delineated using "fences", like this:

```
::: {#welcome .sd-page}

Page 1 content here

:::

::: {#page2 .sd-page}

Page 2 content here

:::
```

As you can see, we use three colon symbols `:::`, called a "fence", to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining [subfigures](https://quarto.org/docs/authoring/figures.html#subfigures) in images.


In the starting fence, you need to define a page name (e.g. `welcome` and `page2` in the example above) and you need to define the class as `.sd-page`. Then anything you put between the page fences will appear on that page. 

To navigate to the next page, you need to insert a `sd_next()` function call inside a code chunk, like this: 

```{r}
#| echo: fenced

sd_next(next_page = 'page2')
```

The above code chunk will create a "Next" button that goes on to page 2 that looks like this:

```{r}
#| eval: true
#| echo: false

sd_next(next_page = 'page2')
```

You would need to place the code chunk in between the `:::` fences of the `welcome` page in order to have a "Next" button that goes on to page 2. You can also send the user to other pages by just changing the `next_page` argument. Finally, you can also change the label of the button by changing the `label` argument, like this:

```{r}
#| echo: fenced

sd_next(next_page = 'page2', label = 'Next page')
```

```{r}
#| eval: true
#| echo: false

sd_next(next_page = 'page2', label = 'Next page')
```

## Adding questions

Every survey question is created using the `sd_question()` function inside a code chunk. The question type is defined by the `type` argument. For example, to add a multiple choice question, you could insert the following code chunk:


```{r}
#| echo: fenced

sd_question(
  type  = 'mc',
  id    = 'penguins',
  label = "Which is your favorite type of penguin?",
  option = c(
    'Adélie'    = 'adelie',
    'Chinstrap' = 'chinstrap',
    'Gentoo'    = 'gentoo'
  )
)
```

The above code chunk will create a multiple choice question that looks like this:

```{r}
#| eval: true
#| echo: false

sd_question(
  type  = 'mc',
  id    = 'penguins',
  label = "Which is your favorite type of penguin?",
  option = c(
    'Adélie'    = 'adelie',
    'Chinstrap' = 'chinstrap',
    'Gentoo'    = 'gentoo'
  )
)
```

The `sd_question()` function can be used to create a variety of [question types](https://jhelvy.github.io/surveydown/articles/question_types.html), like text input, select drop down choices, and more by changing the `type` argument.

The function has many other arguments for customizing the look and feel of the question (e.g., `height` and `width`, etc.) as well as a `required` argument that can be used to make a question required or optional (e.g., `required = TRUE`).

## The server chunk

At the very bottom of the .qmd file is a special "server" code chunk (that's the `#| context: server` bit) that defines the app server. This is where you can customize and control the survey flow logic as well as where you define the database that will store the survey response data. It looks like this:

```{r}
#| echo: fenced
#| context: server

# Define the database settings
db <- sd_database()

# Define the configuration settings
config <- sd_config()

# The sd_server() function initiates your survey - don't change this
sd_server(
  input   = input,
  session = session,
  config  = config,
  db      = db
)
```

The `sd_database()` function is where you set up your database. The `sd_server()` function makes everything run, which you can safely ignore - just don't change it and all will be good!

The middle part (the `sd_config()` function) is where you can define custom control logic for the survey, such as *conditional display* (conditionally displaying a question based on responses to questions), or *conditional skip* (conditionally sending the respondent to a page based on responses to questions).

### Conditional display

Let's say we had a fourth option for "other" in our multiple choice question about penguins. If the respondent chose it, you may want a second question to popup that allows them to specify the other penguin type. To implement this, you would need to define both questions, e.g.:

```{r}
#| echo: fenced

sd_question(
  type  = 'mc',
  id    = 'penguins',
  label = "Which is your favorite type of penguin?",
  option = c(
    'Adélie'    = 'adelie',
    'Chinstrap' = 'chinstrap',
    'Gentoo'    = 'gentoo',
    'Other'     = 'other'
  )
)

sd_question(
  type  = "text",
  id    = "penguins_other",
  label = "Please specify the other penguin type:"
)
```

Then in the server code chunk, you could use the `show_if` argument to define that the `penguins_other` question would only be shown if the respondent chose the `other` option in the `penguins` question, like this:

```{r}
config <- sd_config(
  show_if = tibble::tribble(
    ~question_id,  ~question_value, ~target,
    "penguins",    "other",         "penguins_other"
  )
)
```

This will make the `penguins_other` question only appear if the respondent chose the `other` option in the `penguins` question, like this:

<center>
<img src="show_if.gif" width=600 style="box-shadow: 0 8px 12px 0 rgba(0, 0, 0, 0.3); border: 1px solid #000; border-radius: 5px;">
</center>
<br>

Here we're using the `tibble::tribble()` function to define a data frame with three columns:

- `question_id`: The `id` of the triggering question.
- `question_value`: The triggering value.
- `target`: The `id` of the target question to display.

You don't have to use `tibble::tribble()`, and in fact if you have a lot of `show_if` conditions, then you could create a csv file with all of your conditions in it and read it in to set the `show_if` conditions (just make sure the header has the same three column names), e.g.:

```{r}
config <- sd_config(
  show_if = readr::read_csv('path/to/show_if_conditions.csv')
  )
)
```

### Conditional skip

Often times you'll want to screen people out of a survey based on responses to questions. For example, let's say you only wanted to only include people who own a vehicle. On your first page (e.g., with page name `welcome`), you could screen out people who do _not_ own a vehicle.

First, define a question about their vehicle ownership, e.g.:

```{r}
#| echo: fenced

sd_question(
  type  = 'mc',
  id    = 'vehicle_ownership',
  label = "Do you own your vehicle?",
  option = c(
    'Yes' = 'yes',
    'No'  = 'no'
  )
)
```

Then in the server code chunk, you could use the `skip_if` argument in `sd_config()` to define the behavior of the next button on the `welcome` page, like this:

```{r}
config <- sd_config(
  skip_if = tibble::tribble(
    ~question_id,        ~question_value, ~target,
    "vehicle_ownership", "no",            "screenout"
  )
)
```

This sets up a condition where if the respondent chooses `no` on the `vehicle_ownership` question, they will be sent to a page named `screenout`. You could put such a page at the end of the survey, something like this:

```
::: {#screenout .sd-page}

Sorry, but you are not qualified to take our survey.

:::
```

Notice that I don't have a `sd_next()` on this screenout page. That is how you define an end point for the survey taker. If there's no "Next" button, then they cannot navigate anywhere else, so the survey is over.

### Setting up the database

The `sd_database()` function inside the server code chunk is where you define your database configuration to store your survey response data. The default database is [supabase](https://supabase.com/) - an amazing open-source database project.

The arguments to the `sd_database()` function are all of the components needed to connect to a database hosted on supabase. You can find detailed instructions on how to set this up in the [surveydown documentation](https://jhelvy.github.io/surveydown/articles/database_setup.html). In general, it should look like this:

```{r}
db <- sd_database(
  host       = "",
  db_name    = "",
  port       = "",
  user       = "",
  table_name = "",
  password   = Sys.getenv("SUPABASE_PASSWORD")
)
```

You would fill in each of the currently blank `""` with elements that can be easily copied from your supabase database configuration. For the `password`, we recommend storing your database password in your `.Renviron` file so that it is not accidentally made public (i.e. don't hard-code in your password!), which can then be read into the current environment with the `Sys.getenv()` function.

One configured, any responses on your survey will be stored in your database. You can even check it live - responses are updated on every interaction with the app, such as clicking on a survey question or a next button. The time stamps of each interaction are also automatically stored.

## Going live!

Once you are happy with your survey, you can deploy it live to any server of your choice. Since it's a shiny app, you can deploy it to [shinyapps.io](https://shinyapps.io/) for free. The Quarto documentation has good [instructions](https://quarto.org/docs/interactive/shiny/running.html#shinyapps) on how to deploy a Quarto shiny app to shinyapps.io, and we're working on our own instructions in the package documentation.

# Why did we build surveydown?

> Do we really need another survey platform?

I do a lot of survey research, and I've been frustrated with the survey platforms I've used in the past. The commerical platforms like Qualtrics and SurveyMonkey are great, but they are expensive and are difficult to version control, and collaboration with others is near impossible, especially if your collaborator doesn't have a license of their own. They also don't allow me to own my own survey data, meaning I always am at the mercy of the platform owner. And the features are often limited. It's not easy to do more complex things like randomization, conditional display, etc.

The only other open-source survey platform I have used is [formr](https://formr.org/), which is a very powerful platform, but it is rather clunky to use and is not as easy to edit as a simple markdown file. What we've come up with is a survey platform that is easy to edit, easy to use, and is built entirely on open-source technologies. I think is solves a lot of problems, and hopefully you'll agree.

## Open source

surveydown is built entirely with open-source technologies, making it transparent and customizable. Best of all, no expensive licenses! Just install and use it! 

## Own your data

With surveydown, you retain full ownership and control of your survey data. The responses are stored in your own Supabase database, ensuring that you have complete access to the data. This is particularly important for researchers dealing with sensitive information or those who need to comply with specific data protection regulations. We're still working on enabling you to use your own hosted database, which will provide even more flexibility.

## Ease of editing

Designing a survey in surveydown is a pretty straightforward process. The markdown-based approach allows for quick modifications and easy navigation through your survey. And since it's built on Quarto, you can use all of the features of Quarto to make your survey look great, like changing the theme, adding custom CSS, etc. You can also easily preview your survey as you edit it, and even run your survey locally to test it out before you deploy it, either with a button click in RStudio or with a `quarto preview` command in the terminal.

Some other features we added to make your life easier are:

- The ability to skip to specific pages during editing: in the `sd_config()` function, you can define a `start_page` argument that will skip to a specific page when the survey is first loaded.
- The ability to show all pages at once during editing: in the `sd_config()` function, you can set `show_all_pages = TRUE` to show all the pages at once when the survey is first loaded.
- The ability to define custom / more complex skip logic: in the `sd_config()` function, you can define a `skip_if_custom` argument that allows you to define any custom function that if true will skip to a specific page.
- The ability to define custom / more complex conditional display logic: in the `sd_config()` function, you can define a `show_if_custom` argument that allows you to define any custom function that if true will show a specific question.

## Easy version control and collaboration

Because the entire survey is defined in a single plain text file, surveydown naturally integrates with version control systems like Git. This allows you to track changes over time, collaborate with team members, and maintain a clear history of your survey's development.

## Reproducible

Surveydown promotes reproducible research by allowing you to define your entire survey in a single, self-contained plain text document. This has a ton of benefits, like:

- Want someone else to be able to reproduce your experiment? Just give them the .qmd file and any other files they need (e.g., images, data, etc.), and they can reproduce your survey on their own computer.
- Want to print out your survey for an appendix? Just set `show_all_pages = TRUE` in the `sd_config()` function and print it to pdf.
- Want others to see your survey live? Just turn off the database by setting the database to `db <- sd_database()` with no arguments, and your app will function without a database.

# How we built it

Before I wrap up, I just want to say that I am absolutely amazed at the time we live in. I have had this idea in mind for many years, but I'm not a web developer, and I never could come up with a way to make it happen. That was actually what motivated me to write my [previous blog post](https://jhelvy.com/blog/2023-04-06-markdown-surveys/) - it was a call for help from others!

But two things happened that made it possible:

1. The rise of Quarto
2. The rise of LLMs

After I switched my website over from distill to Quarto, I began to learn more and more about how powerful Quarto really is for building things on the web. Then I saw the [Quarto shiny document](https://quarto.org/docs/dashboards/interactivity/shiny-r.html) framework and I immediately thought that this just might be the missing piece I needed to make surveydown a reality. It does all the legwork of converting markdown and R code into a shiny app. 

Of course, implementing this idea was still really, really hard. There were many different ways to start, and I got some [excellent feedback](https://github.com/quarto-dev/quarto-cli/discussions/6975) from people in the R / Quarto dev community. Garrick Aden-Buie in particular was the first to [propose the idea of using fences](https://github.com/quarto-dev/quarto-cli/discussions/6975#discussioncomment-8828907) to denote page breaks, which was a big breakthrough early on. 

But the real breakthrough came when I started using GPT-4 to help me with trying out many different ideas and developing the overall platform architecture. [This conversation](https://chatgpt.com/share/57fda3b1-2e76-4ab1-b7af-e53eac597986) in particular was game changing. In it, I was able to come to solutions for multiple complex problems, including coming up with the page navigation logic and debating about different platforms for the database. We originally started with using Googlesheets, but ultimately decided on Supabase because it is open-source and just far easier to use.

Of course, the AI didn't do everything. Two of my students, [Pingfan Hu](https://github.com/pingfan-hu) and [Bogdan Bunea](https://github.com/Buneabt) have been instrumental in helping implement many of the features the package now has, and they too have leveraged LLMs to accelerate their problem solving. Thank you guys for all of your hard work! 🙏

It's been amazing watching this project come together over such a short period of time. The original converstaions I had with GPT-4 and others in the R / Quarto community were just in March and April of this year (2024), and we really dodn't start developing in ernest until the summer. In just a few months, we've gone from a simple idea to a fully functional survey platform.

If you give surveydown a try, please let us know what you think! And if you find a bug or something you wished existed, please post an issue on [github](https://github.com/jhelvy/surveydown/issues).

I'm so excited to see what you all will build with surveydown!
