{
  "hash": "0ba7ab2745de9e3ba9e70dd2b0120754",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introducing {surveydown}: An markdown-based framework for generating surveys with Quarto and shiny (that now exists!!!)\"\ndescription: |\n  A quick overview of the {surveydown} R package for making markdown-based surveys with open-source technologies: Quarto, shiny, and supabase.\ndate: '2024-08-08'\npreview: \"logo.png\"\ncategories:\n  - R\n  - package\n  - markdown\n  - shiny\n  - package\n  - quarto\nformat: html\ntoc: true\nlightbox: true\nexecute:\n  eval: false\n---\n\n\n<link rel=\"stylesheet\" href=\"surveydown.css\">\n\n\n\n\n\n<center>\n<img src=\"logo.png\" width=200>\n</center>\n<br>\n\nYou may have read my [previous blog post](https://jhelvy.com/blog/2023-04-06-markdown-surveys/) about an R packaged I called \"surveydown\". That post described some ideas I was thinking about for a package that would allow people to design surveys using markdown and R. But the package didn't exist yet, it was just an idea. \n\nWell, I have good news: **the package now exists!** \n\nIn this post, I'm going to show you a quick overview of the {surveydown} R package for making markdown-based surveys.\n\n# What is surveydown?\n\nIf you've never used surveydown before, the video on [this page]() offers a 5 minute overview that you might find helpful.\n\n[surveydown](https://jhelvy.github.io/surveydown/) is a flexible platform for making surveys in `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 581 512\" style=\"height:1em;width:1.13em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M581 226.6C581 119.1 450.9 32 290.5 32S0 119.1 0 226.6C0 322.4 103.3 402 239.4 418.1V480h99.1v-61.5c24.3-2.7 47.6-7.4 69.4-13.9L448 480h112l-67.4-113.7c54.5-35.4 88.4-84.9 88.4-139.7zm-466.8 14.5c0-73.5 98.9-133 220.8-133s211.9 40.7 211.9 133c0 50.1-26.5 85-70.3 106.4-2.4-1.6-4.7-2.9-6.4-3.7-10.2-5.2-27.8-10.5-27.8-10.5s86.6-6.4 86.6-92.7-90.6-87.9-90.6-87.9h-199V361c-74.1-21.5-125.2-67.1-125.2-119.9zm225.1 38.3v-55.6c57.8 0 87.8-6.8 87.8 27.3 0 36.5-38.2 28.3-87.8 28.3zm-.9 72.5H365c10.8 0 18.9 11.7 24 19.2-16.1 1.9-33 2.8-50.6 2.9v-22.1z\"/></svg>`{=html} using three open source technologies:\n[Quarto](https://quarto.org/), [shiny](https://shiny.posit.co/), and\n[supabase](https://supabase.com/).\n\n<center>\n<img src=\"technologies.png\" width=600>\n</center>\n<br>\n\nThe basic concept is this:\n\n1.  Design your survey as a [Quarto shiny\n    document](https://quarto.org/docs/dashboards/interactivity/shiny-r.html)\n    using markdown and R code.\n2.  Render your doc into a [shiny](https://shiny.posit.co/) app that can\n    be hosted online and sent to respondents.\n3.  Store your survey responses in a [supabase](https://supabase.com/)\n    database.\n\nThe package is still in development, but you can already use it to create surveys. \n\n# Getting started \n\nAfter getting everything [installed](https://jhelvy.github.io/surveydown/articles/installation.html), we recommend starting with a template survey project. You can create one with the following R command:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveydown::sd_create_survey(\"path/to/folder\")\n```\n:::\n\n\nThe `\"path/to/folder\"` is the path to where you want the template to be created. Once created, you'll see the following files / folders:\n\n```\nexample.qmd\n_extensions\nexample.Rproj\n```\n\nThe only file you will need to edit is the `example.qmd` file. This is the main survey file that you will edit and customize for your survey. The `example.Rproj` is just a project file, which I recommend opening to edit your `example.qmd` file in RStudio (if you're using it). Finally, the `_extensions` folder contains the [surveydown Quarto extension](https://github.com/jhelvy/surveydown-ext) needed to make everything work. You can safely ignore this folder - just know that it's needed to make everything work.\n\nIf you have the example open, you can click the \"Run document\" button (in RStudio) or in your terminal run `quarto serve example.qmd`. Either approach should render the example survey into a shiny app that you can preview in a browser. Don't worry just yet about setting up your database or making the survey live - for now, we're going to focus on designing the survey and running it locally to preview it. The example survey should look like this:\n\n<center>\n<img src=\"example.png\" width=700>\n</center>\n\n# A new way to design surveys\n\nIn surveydown, your entire survey is designed using markdown and R code in a single Quarto document. There is no GUI or drag-and-drop interface - simply write plain text (markdown and R code) and boom - you have a survey! \n\nThe [{surveydown} package](https://jhelvy.github.io/surveydown/) provides a set of functions that allow you to define the survey content and control logic. Each function starts with `sd_` to make it easy to identify.\n\nTo edit your survey, you can add text using markdown formatting, or in RStudio you can edit with the visual editor, which inserts the markdown code for you. Survey questions are defined in R code chunks with a `sd_question()` function from the {surveydown} package. Pages are created using fences, with navigation handled with the `sd_next()` function. \n\nOnce all of the survey content is defined (pages, text, images, questions, etc.), you can modify the control logic in the server code chunk (the last code chunk at the bottom of the .qmd file) with the `sd_config()` function. Finally, in the same server code chunk you can define the database configuration with the `sd_database()` function to store the survey response data. \n\nWe'll get to all of this step-by-step.\n\n## Adding pages\n\nIn surveydown, pages are delineated using \"fences\", like this:\n\n```\n::: {#welcome .sd-page}\n\nPage 1 content here\n\n:::\n\n::: {#page2 .sd-page}\n\nPage 2 content here\n\n:::\n\n```\n\nAs you can see, we use three colon symbols `:::`, called a \"fence\", to mark the start and end of pages. This notation is commonly used in Quarto for a variety of use cases, like defining [subfigures](https://quarto.org/docs/authoring/figures.html#subfigures) in images.\n\n\nIn the starting fence, you need to define a page name (e.g. `welcome` and `page2` in the example above) and you need to define the class as `.sd-page`. Then anything you put between the page fences will appear on that page. \n\nTo navigate to the next page, you need to insert a `sd_next()` function call inside a code chunk, like this: \n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nsd_next(next_page = 'page2')\n```\n````\n:::\n\n\nThe above code chunk will create a \"Next\" button that goes on to page 2 that looks like this:\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<button id=\"next-page2\" type=\"button\" class=\"btn btn-default action-button\" style=\"display: block; margin: auto;\" onclick=\"Shiny.setInputValue(&#39;next_page&#39;, &#39;page2&#39;);\">Next</button>\n```\n\n:::\n:::\n\n\nYou would need to place the code chunk in between the `:::` fences of the `welcome` page in order to have a \"Next\" button that goes on to page 2. You can also send the user to other pages by just changing the `next_page` argument. Finally, you can also change the label of the button by changing the `label` argument, like this:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nsd_next(next_page = 'page2', label = 'Next page')\n```\n````\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<button id=\"next-page2\" type=\"button\" class=\"btn btn-default action-button\" style=\"display: block; margin: auto;\" onclick=\"Shiny.setInputValue(&#39;next_page&#39;, &#39;page2&#39;);\">Next page</button>\n```\n\n:::\n:::\n\n\n## Adding questions\n\nEvery survey question is created using the `sd_question()` function inside a code chunk. The question type is defined by the `type` argument. For example, to add a multiple choice question, you could insert the following code chunk:\n\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo'\n  )\n)\n```\n````\n:::\n\n\nThe above code chunk will create a multiple choice question that looks like this:\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div id=\"container- penguins\" data-question-id=\"penguins\" data-required=\"false\" class=\"question-container\">\n<div id=\"penguins\" style=\"width:100%;\" class=\"form-group shiny-input-radiogroup shiny-input-container\" role=\"radiogroup\" aria-labelledby=\"penguins-label\">\n<label class=\"control-label\" id=\"penguins-label\" for=\"penguins\"><p>Which is your favorite type of penguin?</p>\n</label>\n<div class=\"shiny-options-group\">\n<div class=\"radio\">\n<label>\n<input type=\"radio\" name=\"penguins\" value=\"adelie\"/>\n<span>Adélie</span>\n</label>\n</div>\n<div class=\"radio\">\n<label>\n<input type=\"radio\" name=\"penguins\" value=\"chinstrap\"/>\n<span>Chinstrap</span>\n</label>\n</div>\n<div class=\"radio\">\n<label>\n<input type=\"radio\" name=\"penguins\" value=\"gentoo\"/>\n<span>Gentoo</span>\n</label>\n</div>\n</div>\n</div>\n</div>\n```\n\n:::\n:::\n\n\nThe `sd_question()` function can be used to create a variety of [question types](https://jhelvy.github.io/surveydown/articles/question_types.html), like text input, select drop down choices, and more by changing the `type` argument.\n\nThe function has many other arguments for customizing the look and feel of the question (e.g., `height` and `width`, etc.) as well as a `required` argument that can be used to make a question required or optional (e.g., `required = TRUE`).\n\n## The server chunk\n\nAt the very bottom of the .qmd file is a special \"server\" code chunk (that's the `#| context: server` bit) that defines the app server. This is where you can customize and control the survey flow logic as well as where you define the database that will store the survey response data. It looks like this:\n\n\n::: {.cell context='server'}\n\n````{.cell-code}\n```{{r}}\n#| context: server\n\n# Define the database settings\ndb <- sd_database()\n\n# Define the configuration settings\nconfig <- sd_config()\n\n# The sd_server() function initiates your survey - don't change this\nsd_server(\n  input   = input,\n  session = session,\n  config  = config,\n  db      = db\n)\n```\n````\n:::\n\n\nThe `sd_database()` function is where you set up your database. The `sd_server()` function makes everything run, which you can safely ignore - just don't change it and all will be good!\n\nThe middle part (the `sd_config()` function) is where you can define custom control logic for the survey, such as *conditional display* (conditionally displaying a question based on responses to questions), or *conditional skip* (conditionally sending the respondent to a page based on responses to questions). \n\n### Conditional display\n\nLet's say we had a fourth option for \"other\" in our multiple choice question about penguins. If the respondent chose it, you may want a second question to popup that allows them to specify the other penguin type. To implement this, you would need to define both questions, e.g.:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nsd_question(\n  type  = 'mc',\n  id    = 'penguins',\n  label = \"Which is your favorite type of penguin?\",\n  option = c(\n    'Adélie'    = 'adelie',\n    'Chinstrap' = 'chinstrap',\n    'Gentoo'    = 'gentoo',\n    'Other'     = 'other'\n  )\n)\n\nsd_question(\n  type  = \"text\",\n  id    = \"penguins_other\",\n  label = \"Please specify the other penguin type:\"\n)\n```\n````\n:::\n\n\nThen in the server code chunk, you could use the `show_if` argument to define that the `penguins_other` question would only be shown if the respondent chose the `other` option in the `penguins` question, like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfig <- sd_config(\n  show_if = tibble::tribble(\n    ~question_id,  ~question_value, ~target,\n    \"penguins\",    \"other\",         \"penguins_other\"\n  )\n)\n```\n:::\n\n\nHere we're using the `tibble::tribble()` function to define a data frame with three columns: \n\n- `question_id`: The `id` of the triggering question. \n- `question_value`: The triggering value. \n- `target`: The `id` of the target question to display.\n\nYou don't have to use `tibble::tribble()`, and in fact if you have a lot of `show_if` conditions, then you could create a csv file with all of your conditions in it and read it in to set the `show_if` conditions (just make sure the header has the same three column names), e.g.:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfig <- sd_config(\n  show_if = readr::read_csv('path/to/show_if_conditions.csv')\n  )\n)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n### Conditional skip\n\nOften times you'll want to screen people out of a survey based on responses to questions. For example, let's say you had a survey about vehicle owners and wanted to only include people who owned their vehicle. On your first page (named `welcome`), you could screen out people who do _not_ own their vehicle by first defining a question about their vehicle ownership, e.g.:\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\nsd_question(\n  type  = 'mc',\n  id    = 'vehicle_ownership',\n  label = \"Do you own your vehicle?\",\n  option = c(\n    'Yes'    = 'yes',\n    'No' = 'no'\n  )\n)\n```\n````\n:::\n\n\nThen in the server code chunk, you could use the `skip_if` argument to define the behavior of the next button on the `welcome` page: if the respondent chose `yes`, they would go to the next page defined by the `sd_next()` function on the `welcome` page (the default behavior), but if they chose `no` you could send them to some page at the end, e.g. a page named `screenout`. the `vehicle_ownership` question would only be shown if the respondent chose the `other` option in the `penguins` question, like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfig <- sd_config(\n  show_if = tibble::tribble(\n    ~question_id,  ~question_value, ~target,\n    \"penguins\",    \"other\",         \"penguins_other\"\n  )\n)\n```\n:::\n\n\nHere we're using the `tibble::tribble()` function to define a data frame with three columns: \n\n- `question_id`: The `id` of the triggering question. \n- `question_value`: The triggering value. \n- `target`: The `id` of the target question to display.\n\nYou don't have to use `tibble::tribble()`, and in fact if you have a lot of `show_if` conditions, then you could create a csv file with all of your conditions in it and read it in to set the `show_if` conditions (just make sure the header has the same three column names), e.g.:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconfig <- sd_config(\n  show_if = readr::read_csv('path/to/show_if_conditions.csv')\n  )\n)\n```\n:::\n\n\n\n\n## Setting up the database\n\nThe `sd_database()` function inside the server code chunk is where you can define your database configuration to store your survey response data. The default database is [supabase](https://supabase.com/), an open-source database.\n\nThe arguments to the `sd_database()` function are all of the components needed to connect to a database hosted on supabase. You can find detailed instructions on how to set this up in the [surveydown documentation](https://jhelvy.github.io/surveydown/articles/database_setup.html). In general, it should look like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndb <- sd_database(\n  host       = \"\",\n  db_name    = \"\",\n  port       = \"\",\n  user       = \"\",\n  table_name = \"\",\n  password   = Sys.getenv(\"SUPABASE_PASSWORD\")\n)\n```\n:::\n\n\nEach of the characters are elements that can be easily copied from your supabase database configuration. We recommend storing your database password in your `.Renviron` file so that it is not accidentally made public (i.e. don't hard-code in your password!), which can be accessed with the `Sys.getenv()` function.\n\nOne configured, any responses on your survey will be stored in your database. You can even check it live - responses are updated on every interaction with the app, such as clicking on a survey question or a next button. The time stamps of each interaction are also automatically stored.\n\n# What problem(s) does surveydown solve?\n\n## Open source\n## Free\n## Own your data\n## Ease of editing - skip to page, etc\n## Version control\n## Reproducible\n\n# How we built it\n\nAI help",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}